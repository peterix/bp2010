Index: kdecore/kernel/kauthorized.h
===================================================================
--- kdecore/kernel/kauthorized.h	(revision 1125109)
+++ kdecore/kernel/kauthorized.h	(working copy)
@@ -23,6 +23,7 @@
 
 #include <kdecore_export.h>
 
+class KConfig;
 class KUrl;
 class QString;
 class QStringList;
@@ -90,6 +91,15 @@
    */
   KDE_EXPORT QStringList authorizeControlModules(const QStringList& menuIds);
 
+  /**
+  * Return a list of names of restricted resources given a KConfig reference.
+  *
+  * @param config A KConfig object to probe for restrictions;
+  * See KStandardDirs documentation for a list of possible resources
+  * @param toAuthorize A list of resource types to authorize
+  * @return Those resources for which access has been restricted.
+  */
+  KDE_EXPORT QStringList authorizeResourceTypes(const KConfig* config, QStringList & toAuthorize);
 }
 
 #endif
Index: kdecore/kernel/kstandarddirs.h
===================================================================
--- kdecore/kernel/kstandarddirs.h	(revision 1125109)
+++ kdecore/kernel/kstandarddirs.h	(working copy)
@@ -532,6 +532,15 @@
                            SearchOptions options = NoSearchOptions );
 
     /**
+     * Fills the map of restricted resources using a KConfig object.
+     * Rerun after adding Kiosk profiles to config paths.
+     *
+     * @param config The object the entries are read from. This should
+     *        contain global config files
+     */
+    void evaluateRestrictedResources(KConfig *config);
+    
+    /**
      * Reads customized entries out of the given config object and add
      * them via addResourceDirs().
      *
Index: kdecore/kernel/kcomponentdata.cpp
===================================================================
--- kdecore/kernel/kcomponentdata.cpp	(revision 1125109)
+++ kdecore/kernel/kcomponentdata.cpp	(working copy)
@@ -140,7 +140,10 @@
         configInit(component);
 
         if (dirs->addCustomized(sharedConfig.data()))
+        {
             sharedConfig->reparseConfiguration();
+            dirs->evaluateRestrictedResources(sharedConfig.data());
+        }
     }
     
     // the first KComponentData sets the KDE Qt plugin paths
Index: kdecore/kernel/kauthorized.cpp
===================================================================
--- kdecore/kernel/kauthorized.cpp	(revision 1125109)
+++ kdecore/kernel/kauthorized.cpp	(working copy)
@@ -22,7 +22,9 @@
 
 #include <QtCore/QDir>
 #include <QtCore/QRegExp>
-#include <QList>
+#include <QtCore/QList>
+#include <QtCore/QSet>
+#include <QtCore/QDebug>
 
 
 #include <QCoreApplication>
@@ -35,6 +37,9 @@
 #include <netdb.h>
 #include <kurl.h>
 #include <kconfiggroup.h>
+#include <kdebug.h>
+#include <kauth.h>
+#include <BackendsManager.h>
 
 #include <QMutex>
 #include <QMutexLocker>
@@ -201,7 +206,11 @@
   ~KAuthorizedPrivate()
   {
   }
-
+  
+  bool KioskAuthorize(const QString KioskGroup, const QString nspace, const QString& action);
+  
+  QString stripIllegal (const QString & input);
+  
   bool actionRestrictions : 1;
   bool blockEverything : 1;
   QList<URLActionRule> urlActionRestrictions;
@@ -211,46 +220,214 @@
 Q_GLOBAL_STATIC(KAuthorizedPrivate,authPrivate)
 #define MY_D KAuthorizedPrivate *d=authPrivate();
 
-
-bool KAuthorized::authorize(const QString &genericAction)
+// strip illegal characters from names used in KAuth/its backends
+QString KAuthorizedPrivate::stripIllegal (const QString & input)
 {
-   MY_D
-   if (d->blockEverything) return false;
+    // make action name lowercase
+    QString lowerAction = input.toLower();
 
-   if (!d->actionRestrictions)
-      return true;
+    // strip unsupported characters
+    QString stripped;
+    stripped.reserve(lowerAction.length());
+    for(int i = 0; i < lowerAction.length(); i++)
+    {
+        QChar c = lowerAction[i];
+        if((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9'))
+        {
+            stripped.append(c);
+        }
+    }
+    return stripped;
+}
 
-   KConfigGroup cg(KGlobal::config(), "KDE Action Restrictions");
-   return cg.readEntry(genericAction, true);
+bool KAuthorizedPrivate::KioskAuthorize(const QString KioskGroup, const QString nspace, const QString& action)
+{
+    /*
+     * Variant using KAuth::Action::execute(). Straight out of the KAuth tutorial.
+     * can't detect when KAuth doesn't know the action. Doesn't seem work at all.
+     */
+    if(0)
+    {
+        QString aname = QString("org.kde.kiosk.%1.%2").arg(nspace,stripIllegal(action));
+        KAuth::Action commonAction(aname);
+        KAuth::ActionReply reply = commonAction.execute();
+        if (reply.failed())
+        {
+            qDebug() << "Failed to authorize" << aname << "using KAuth";
+            return false;
+        }
+        else
+        {
+            // Do your stuff here...
+            qDebug() << "Authorized" << aname << "using KAuth";
+            return true;
+        }
+    }
+    
+    /*
+     * Variant using KAuth::Action::authorize() -- 'NOP' in case of Polkit1
+     */
+    if(0)
+    {
+        QString aname = QString("org.kde.kiosk.%1.%2").arg(nspace,stripIllegal(action));
+        KAuth::Action commonAction(aname);
+        KAuth::Action::AuthStatus auth = commonAction.authorize();
+        KConfigGroup cg(KGlobal::config(), KioskGroup);
+        switch(auth)
+        {
+            case KAuth::Action::Denied:
+                qDebug() << "Action " << aname << "denied by KAuth";
+                return false;
+            case KAuth::Action::Authorized:
+                qDebug() << "Action " << aname << "allowed by KAuth";
+                return true;
+            case KAuth::Action::Invalid:
+                // fallback to KConfig if we can't find the KAuth action
+                qDebug() << "Action " << aname << "handled by KConfig";
+                return cg.readEntry(action, true);
+            default:
+                // catch-all
+                qDebug() << "received unexpected result from commonAction.authorize(): " << auth;
+            return false;
+        }
+        return false;
+    }
+    
+    /*
+     * Variant using KAuth::Action::status(). Works, session started with this
+     * self-destructs after a short while.
+     * This uses the synchronous authorization check
+     */
+    if(0)
+    {
+        QString aname = QString("org.kde.kiosk.%1.%2").arg(nspace,stripIllegal(action));
+        KAuth::Action commonAction(aname);
+        KAuth::Action::AuthStatus auth = commonAction.status();
+        KConfigGroup cg(KGlobal::config(), KioskGroup);
+        switch(auth)
+        {
+            case KAuth::Action::Denied:
+                qDebug() << "Action " << aname << "denied by KAuth";
+                return false;
+            case KAuth::Action::Authorized:
+                qDebug() << "Action " << aname << "allowed by KAuth";
+                return true;
+            case KAuth::Action::Invalid:
+                // fallback to KConfig if we can't find the KAuth action
+                qDebug() << "Action " << aname << "handled by KConfig";
+                return cg.readEntry(action, true);
+            default:
+                // catch-all
+                qDebug() << "received unexpected result from commonAction.status(): " << auth;
+            return false;
+        }
+        return false;
+    }
+    
+    /*
+     * Variant using BackendManager together with other things
+     */
+    if(0)
+    {
+        QString aname = QString("org.kde.kiosk.%1.%2").arg(nspace,stripIllegal(action));
+        KAuth::AuthBackend * backend = KAuth::BackendsManager::authBackend();
+        bool authed = backend->isCallerAuthorized(aname,backend->callerID());
+        if(authed)
+        {
+            qDebug() << aname << "authorized by isCallerAuthorized";
+        }
+        else
+        {
+            qDebug() << aname << "NOT authorized by isCallerAuthorized";
+        }
+        return authed;
+        /*
+        KAuth::Action commonAction(aname);
+        KAuth::Action::AuthStatus auth = commonAction.authorize();
+        KConfigGroup cg(KGlobal::config(), KioskGroup);
+        switch(auth)
+        {
+            case KAuth::Action::Denied:
+                qDebug() << "Action " << aname << "denied by KAuth";
+                return false;
+            case KAuth::Action::Authorized:
+                qDebug() << "Action " << aname << "allowed by KAuth";
+                return true;
+            case KAuth::Action::Invalid:
+                // fallback to KConfig if we can't find the KAuth action
+                qDebug() << "Action " << aname << "handled by KConfig";
+                return cg.readEntry(action, true);
+            default:
+                // catch-all
+                qDebug() << "received unexpected result from commonAction.authorize(): " << auth;
+            return false;
+        }
+        return false;
+        */
+    }
+    
+    /*
+     * Original variant - old, as safe as it gets without disabling debugging. also fast.
+     */
+    if(1)
+    {
+        MY_D
+        KConfigGroup cg(KGlobal::config(), KioskGroup);
+        return cg.readEntry(action, true);
+    }
+    return true;
 }
 
+bool KAuthorized::authorize(const QString &genericAction)
+{
+    MY_D
+    if (d->blockEverything) return false;
+    if (!d->actionRestrictions || genericAction.isEmpty())
+        return true;
+    
+    return d->KioskAuthorize(QString("KDE Action Restrictions"),
+                             QString("action"),
+                             genericAction);
+}
+
 bool KAuthorized::authorizeKAction(const QString& action)
 {
-   MY_D
-   if (d->blockEverything) return false;
-   if (!d->actionRestrictions || action.isEmpty())
-      return true;
-
-   return authorize(QLatin1String("action/") + action);
+    MY_D
+    if (d->blockEverything) return false;
+    if (!d->actionRestrictions || action.isEmpty())
+        return true;
+    return authorize(QLatin1String("action/") + action);
 }
 
 bool KAuthorized::authorizeControlModule(const QString &menuId)
 {
-   if (menuId.isEmpty() || kde_kiosk_exception)
-      return true;
-   KConfigGroup cg(KGlobal::config(), "KDE Control Module Restrictions");
-   return cg.readEntry(menuId, true);
+    MY_D
+    if (menuId.isEmpty() || kde_kiosk_exception)
+        return true;
+    
+    return d->KioskAuthorize(QString("KDE Control Module Restrictions"),
+                             QString("kcmodule"),
+                             menuId);
+
+    /*
+    KConfigGroup cg(KGlobal::config(), "KDE Control Module Restrictions" );
+    return cg.readEntry(menuId, true);
+    */
 }
 
 QStringList KAuthorized::authorizeControlModules(const QStringList &menuIds)
 {
-   KConfigGroup cg(KGlobal::config(), "KDE Control Module Restrictions");
-   QStringList result;
-   for(QStringList::ConstIterator it = menuIds.begin();
-       it != menuIds.end(); ++it)
-   {
-      if (cg.readEntry(*it, true))
-         result.append(*it);
+    MY_D
+    KConfigGroup cg(KGlobal::config(), "KDE Control Module Restrictions");
+    QStringList result;
+    for(QStringList::ConstIterator it = menuIds.begin();
+        it != menuIds.end(); ++it)
+    {
+        if(d->KioskAuthorize(QString("KDE Control Module Restrictions"),
+                             QString("kcmodule"),
+                             *it))
+        //if (cg.readEntry(*it, true))
+            result.append(*it);
    }
    return result;
 }
@@ -378,3 +555,52 @@
   }
   return result;
 }
+extern bool kde_kiosk_admin;
+
+QStringList KAuthorized::authorizeResourceTypes(const KConfig* config, QStringList & toAuthorize)
+{
+    QStringList result;
+    MY_D
+    
+    // better be safe than sorry, return empty list for null pointer
+    if(!config)
+        return result;
+    
+    // Process KIOSK restrictions.
+    if (!kde_kiosk_admin || qgetenv("KDE_KIOSK_NO_RESTRICTIONS").isEmpty())
+    {
+        if(0)
+        {
+            // probe KAuth-stored restrictions first
+            foreach(QString resource, toAuthorize)
+            {
+                KAuth::Action Resource(
+                    QString("org.kde.kiosk.resource.%1").arg(d->stripIllegal(resource))
+                        );
+                if(Resource.status() == KAuth::Action::Denied)
+                {
+                    //kDebug() << "Restricted resource" << key;
+                    result.append(resource);
+                }
+            }
+        }
+        // then probe KConfig-stored restrictions
+        KConfigGroup cg(config, "KDE Resource Restrictions");
+        const QMap<QString, QString> entries = cg.entryMap();
+        for (QMap<QString, QString>::ConstIterator it2 = entries.begin();
+        it2 != entries.end(); ++it2)
+        {
+            const QString resource = it2.key();
+            // resources are allowed by default (restricted = false here)
+            if (toAuthorize.contains(resource) && !cg.readEntry(resource, true))
+            {
+                //kDebug() << "Restricted resource" << key;
+                result.append(resource);
+            }
+        }
+        // remove duplicates
+        return result.toSet().toList();
+    }
+    // Kiosk restrictions don't apply, return empty list
+    return result;
+}
\ No newline at end of file
Index: kdecore/kernel/kstandarddirs.cpp
===================================================================
--- kdecore/kernel/kstandarddirs.cpp	(revision 1125109)
+++ kdecore/kernel/kstandarddirs.cpp	(working copy)
@@ -35,6 +35,7 @@
 #include "kkernel_win.h"
 #include "kkernel_mac.h"
 #include "klocale.h"
+#include "kauthorized.h"
 
 #include <config.h>
 #include <config-prefix.h>
@@ -244,14 +245,18 @@
 bool KStandardDirs::isRestrictedResource(const char *type, const QString& relPath) const
 {
     if (!d->m_restrictionsActive)
+    {
+        // qDebug() << "No restriction present" << relPath;
         return false;
+    }
 
     if (d->m_restrictions.value(type, false))
         return true;
 
     if (strcmp(type, "data")==0 && d->hasDataRestrictions(relPath))
         return true;
-
+    
+    // qDebug() << type << "is not restricted with path" << relPath;
     return false;
 }
 
@@ -1896,6 +1901,28 @@
 
 extern bool kde_kiosk_admin;
 
+void KStandardDirs::evaluateRestrictedResources(KConfig *config)
+{
+    // Process KIOSK restrictions.
+    
+    // get list of restricted resources
+    QStringList toAuthorize = allTypes();
+    QStringList restricted = KAuthorized::authorizeResourceTypes(config, toAuthorize);
+    // add them to the m_restrictions map
+    for(QStringList::const_iterator it2 = restricted.begin(); it2 < restricted.end(); ++it2)
+    {
+        const QString key = *it2;
+        QByteArray lat1key = key.toLatin1();
+        if(d->m_restrictions.find(lat1key) == d->m_restrictions.end())
+        {
+            d->m_restrictionsActive = true;
+            d->m_restrictions.insert(lat1key, true);
+            d->m_dircache.remove(lat1key);
+            // qDebug() << key << "is restricted additionally!";
+        }
+    }
+}
+
 bool KStandardDirs::addCustomized(KConfig *config)
 {
     if (!d->m_checkRestrictions) // there are already customized entries
@@ -1993,8 +2020,10 @@
             priority = true;
         }
     }
-
-    // Process KIOSK restrictions.
+    
+    evaluateRestrictedResources(config);
+    
+    /*
     if (!kde_kiosk_admin || qgetenv("KDE_KIOSK_NO_RESTRICTIONS").isEmpty())
     {
         KConfigGroup cg(config, "KDE Resource Restrictions");
@@ -2011,6 +2040,7 @@
             }
         }
     }
+    */
 
     // check if the number of config dirs changed
     bool configDirsChanged = (resourceDirs("config").count() != configdirs);
Index: kdecore/auth/org.kde.kiosk.action.actions
===================================================================
--- kdecore/auth/org.kde.kiosk.action.actions	(revision 0)
+++ kdecore/auth/org.kde.kiosk.action.actions	(revision 0)
@@ -0,0 +1,89 @@
+[Domain]
+Name=Kiosk action restrictions
+Icon=kioks-actions
+URL=http://techbase.kde.org/
+
+[org.kde.kiosk.action.plasmadesktopscriptingconsole]
+Name=Allow using the Plasma scripting console
+Description=Trying to run the Plasma scripting console
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.action.runcommand]
+Name=Allow running commands from KRunner
+Description=Trying to run a command from KRunner
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.action.switchuser]
+Name=Allow switching to another user
+Description=Trying to switch to another user
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.action.lockscreen]
+Name=Allow locking the screen
+Description=Trying to lock the screen
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.action.rundesktopfiles]
+Name=Allow the user to run .desktop files
+Description=Trying to run a .desktop file
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.action.shellaccess]
+Name=Allow access to a shell in KDE
+Description=Trying to open a shell in KDE
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.action.editabledesktopicons]
+Name=Allow the user to change Plasma applets
+Description=Kiosk is probing if the user is allowed to change Plasma applets
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.action.actionkdesktoprmb]
+Name=Allow the user to use the right mouse button menu on the desktop
+Description=Kiosk is probing if the user is allowed to use the right mouse button menu on the desktop
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.action.movabletoolbars]
+Name=Allow toolbars to be rearranged by the user
+Description=Kiosk is probing if the user is allowed to rearrange toolbars
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.action.plasmaallowconfigurewhenlocked]
+Name=Allow plasma applets to be configued while locked
+Description=Kiosk is probing if the user is allowed to rearrange toolbars
+Policy=yes
+Persistence=session
+
+
+[org.kde.kiosk.action.lineedittextcompletion]
+Name=Allow auto-complete in a KLineEdit widget
+Description=Kiosk is probing if the user is allowed to use auto-completion in a KLineEdit widget
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.action.warnunwritableconfig]
+Name=Show a warning if the configuration files of an application are not writable
+Description=Kiosk is probing if a warnig should be shown when an application's configuration files are not writable
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.action.logout]
+Name=Allow the user to log out using global shortcuts
+Description=Kiosk is probing if the user is allowed to log out
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.action.actionhelp]
+Name=Show help menu
+Description=Trying to show the help menu
+Policy=yes
+Persistence=session
\ No newline at end of file
Index: kdecore/auth/org.kde.kiosk.resource.actions
===================================================================
--- kdecore/auth/org.kde.kiosk.resource.actions	(revision 0)
+++ kdecore/auth/org.kde.kiosk.resource.actions	(revision 0)
@@ -0,0 +1,136 @@
+[Domain]
+Name=Kiosk common resource restrictions
+Icon=kioks-actions
+URL=http://techbase.kde.org/
+
+[org.kde.kiosk.resource.apps]
+Name=Applications menu (.desktop files).
+Description=Do not restrict applications menu resources
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.autostart]
+Name=Autostart directories (both XDG and kde-specific)
+Description=Do not restrict autostart directories
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.cache]
+Name=Cached information (e.g. favicons, web-pages)
+Description=Do not restrict cached information resources
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.cgi]
+Name=CGIs to run from kdehelp.
+Description=Do not restrict kdehelp CGI resources
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.config]
+Name=Configuration files.
+Description=Do not restrict configuration resources
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.data]
+Name=Where applications store data.
+Description=Do not restrict application data resources
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.emoticons]
+Name=Emoticons themes
+Description=Do not restrict emoticon theme resources
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.exe]
+Name=Executables in $prefix/bin. findExe() for a function that takes $PATH into account.
+Description=Do not restrict executable file resources
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.html]
+Name=HTML documentation.
+Description=Do not restrict html documentation resources
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.icon]
+Name=Icons, see KIconLoader.
+Description=Do not restrict icon resources
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.kcfg]
+Name=KConfigXT config files.
+Description=Do not restrict resources for KConfigXT
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.lib]
+Name=Libraries
+Description=Do not restrict library resources
+Policy=yes
+Persistence=session
+ 
+[org.kde.kiosk.resource.locale]
+Name=Translation files for KLocale.
+Description=Do not restrict translation resources
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.mime]
+Name=Mime types defined by KDE-specific .desktop files.
+Description=Do not restrict KDE-speific mime type resources
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.module]
+Name=Module (dynamically loaded library).
+Description=Do not restrict dynamic loaded module resources
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.qtplugins]
+Name=Qt plugins (dynamically loaded objects for Qt)
+Description=Do not restrict Qt plugin resources
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.services]
+Name=Services
+Description=Do not restrict KDE service resources
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.servicetypes]
+Name=Service types.
+Description=Do not restrict KDE service type resources
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.sound]
+Name=Application sounds
+Description=Do not restrict KDE application sound resources
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.templates]
+Name=Templates for the "Create new file" functionality.
+Description=Do not restrict templates for the "Create new file" functionality.
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.wallpaper]
+Name=Wallpapers
+Description=Do not restrict wallpaper resources.
+Policy=yes
+Persistence=session
+
+[org.kde.kiosk.resource.tmp]
+Name=Temporary files (specific for both current host and current user)
+Description=Do not restrict temporary file resources
+Policy=yes
+Persistence=session
\ No newline at end of file
Index: kdecore/auth/kauthDoS.cpp
===================================================================
--- kdecore/auth/kauthDoS.cpp	(revision 0)
+++ kdecore/auth/kauthDoS.cpp	(revision 0)
@@ -0,0 +1,48 @@
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <pwd.h>
+#include <grp.h>
+
+#include <QtCore/QCoreApplication>
+#include <QtCore/QFile>
+
+#include <kaboutdata.h>
+#include <kcmdlineargs.h>
+#include <kglobal.h>
+#include <klocale.h>
+#include <kcomponentdata.h>
+#include <kshell.h>
+#include <kstandarddirs.h>
+#include <kconfiggroup.h>
+#include <kauth.h>
+#include <kdebug.h>
+#include <iostream>
+using namespace KAuth;
+
+int main(int argc, char **argv)
+{
+    QCoreApplication app(argc, argv);
+    KLocale::setMainCatalog("kauthDoS");
+    KAboutData about("kauthDoS",0, ki18n( "kauthDoS" ), "1.0", ki18n("A tool to test some aspects of KAuth."), KAboutData::License_GPL, ki18n( "(C) 2010 Petr Mrázek" ));
+    KCmdLineArgs::init( argc, argv, &about);
+    KComponentData mainComponent(about);
+    KCmdLineArgs *args = KCmdLineArgs::parsedArgs();
+
+    QVariantMap helperargs;
+    // fill in helper args here
+    
+    // testing fake actions, not requiring user intervention
+    int index = 1;
+    forever
+    {
+        Action action(QString("org.kde.fake%1").arg(index));
+        action.status();
+        if(index % 1000 == 0)
+            std::cout << "org.kde.fake." << index << std::endl;
+        index++;
+    }
+    return 0;
+}
+
+
Index: kdecore/auth/pklahelper_actions.actions
===================================================================
--- kdecore/auth/pklahelper_actions.actions	(revision 0)
+++ kdecore/auth/pklahelper_actions.actions	(revision 0)
@@ -0,0 +1,14 @@
+[Domain]
+Name=Kiosk profile to PolicyKit1 converter
+Name[cs]=Překladač Kiosk profilů do PolicyKit1
+Name[en_GB]=Kiosk profile to PolicyKit1 converter
+Icon=preferences-system-time
+
+[org.kde.kiosk.pklahelper.convertall]
+Name=Convert all Kiosk profiles into PolicyKit1 Local Authority config files
+Name[cs]=Konvertovat všechny Kiosk profily na soubory s nastavením pro PolicyKit1 Local Authority
+Name[en_GB]=Convert all Kiosk profiles into PolicyKit1 Local Authority config files
+Description=System policies prevent you from converting Kiosk profiles into PolicyKit1 settings.
+Description[cs]=Nastavení systému vám znemožňuje konvertovat Kiosk profily na nastavení pro PolicyKit1.
+Description[en_GB]=System policies prevent you from converting Kiosk profiles into PolicyKit1 settings.
+Policy=auth_admin
Index: kdecore/auth/kioskpklahelper.cpp
===================================================================
--- kdecore/auth/kioskpklahelper.cpp	(revision 0)
+++ kdecore/auth/kioskpklahelper.cpp	(revision 0)
@@ -0,0 +1,543 @@
+/*
+ *  kioskpklahelper.cpp
+ *
+ *  Copyright (C) 2004 Waldo Bastian <bastian@kde.org>
+ *  Copyright (C) 2009 Ian Reinhart Geiser <geiseri@kde.org>
+ *  Copyright (C) 2010 Petr Mrázek <xmraze03@stud.fit.vutbr.cz>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+/*
+ * This file contains some code borrowed from KioskTool
+ */
+
+#include "kioskpklahelper.h"
+
+#include <kcomponentdata.h>
+#include <kaboutdata.h>
+#include <kconfig.h>
+#include <kconfiggroup.h>
+#include <kstandarddirs.h>
+#include <kprocess.h>
+
+#include <QtCore/QDir>
+#include <QtCore/QDirIterator>
+#include <QtCore/QFile>
+#include <QtCore/QDebug>
+#include <polkitqt1-authority.h>
+
+// Maps a single group or user to a one or more profiles
+typedef QMap<QString,QStringList> ProfileMapping;
+
+// from KioskTool
+// get default profile prefix
+QString getProfilePrefix()
+{
+    //KConfig fullPath("/etc/kde4rc");
+    KConfigGroup grp( KGlobal::config(), "Directories");
+    
+    QString prefix = grp.readEntry("profileDirsPrefix");
+    if (!prefix.isEmpty() && !prefix.endsWith("/"))
+        prefix.append('/');
+    return prefix;
+}
+
+// from KioskTool
+// get all profiles as QStringList
+QStringList getAllProfiles()
+{
+    KSharedConfigPtr config = KGlobal::config();
+    //KConfig config("/etc/kde4rc");
+    QStringList groups = config->groupList();
+    QStringList profiles;
+    QStringList directories;
+    foreach( QString group, groups )
+    {
+        if (!group.startsWith("Directories-"))
+            continue;
+        profiles.append(group.mid(12));
+        KConfigGroup grp =  config->group(group);
+        QString installDir = grp.readEntry("prefixes");
+        if (!installDir.endsWith("/"))
+            installDir.append("/");
+        directories.append(installDir);
+    }
+
+    QString profilePrefix = getProfilePrefix();
+    if (!profilePrefix.isEmpty())
+    {
+        QDir dir(profilePrefix, QString(), QDir::Unsorted, QDir::Dirs);
+        QStringList profileDirs = dir.entryList();
+        foreach( QString profileDir, profileDirs )
+        {
+            if (profileDir.startsWith("."))
+                continue;
+            QString dir = profilePrefix + profileDir + "/";
+            if (directories.contains(dir))
+            {
+                qDebug() << "Skipping " << dir << ", dir already listed" << endl;
+                continue;
+            }
+            if (profiles.contains(profileDir))
+            {
+                qDebug() << "Skipping " << dir << ", profile [" << profileDir << "] already listed" << endl;
+                continue;
+            }
+
+            if (!QFile::exists(dir+".kdeprofile"))
+            {
+                qDebug() << "Skipping " << dir << ", no profile info" << endl;
+                continue;
+            }
+            profiles.append(profileDir);
+            directories.append(dir);
+        }
+    }
+
+    if (!profiles.contains("default"))
+        profiles.append("default");
+
+    return profiles;
+}
+
+// taken from kiosktool
+// get mappings between users and profiles, groups and profiles and the stacking order of groups
+void getUserProfileMappings( ProfileMapping &groups, ProfileMapping &users, QStringList &groupOrder)
+{
+    groups.clear();
+    users.clear();
+
+    KConfigGroup config( KGlobal::config(), "Directories");
+    QString mapFile = config.readEntry("userProfileMapFile");
+
+    if (mapFile.isEmpty() || !QFile::exists(mapFile))
+        return;
+
+    KConfig mapCfg(mapFile, KConfig::SimpleConfig);
+
+    KConfigGroup grp = mapCfg.group("General");
+    groupOrder = grp.readEntry("groups", QStringList());
+
+    grp = mapCfg.group("Groups");
+    foreach( QString group, groupOrder )
+    {
+        QStringList profiles = grp.readEntry(group, QStringList());
+        if (!profiles.isEmpty())
+            groups.insert(group, profiles);
+    }
+
+    QMap<QString, QString> cfg_users = mapCfg.entryMap("Users");
+    foreach( QString key, cfg_users.keys() )
+    {
+        QString user = key;
+        QStringList profiles = cfg_users[key].split(',');
+        if (!profiles.isEmpty())
+            users.insert(user, profiles);
+    }
+}
+
+// from KioskTool
+// Read information of profile @p profile
+void getProfileInfo(const QString &profile, QString &description, QString &installDir, QString &installUser)
+{
+    QString defaultInstallDir = getProfilePrefix();
+    if (defaultInstallDir.isEmpty())
+    {
+        defaultInstallDir = "/etc/kde-profile/";
+    }
+    if (!defaultInstallDir.endsWith("/"))
+        defaultInstallDir.append("/");
+    QString tmp = profile;
+    tmp.replace(" ", "_");
+    tmp.replace(":", "_");
+    tmp.replace("/", "_");
+    defaultInstallDir += tmp+"/";
+
+    QString group = QString("Directories-%1").arg(profile);
+    KConfigGroup grp(KGlobal::config(), group );
+
+    installDir = grp.readEntry("prefixes", defaultInstallDir);
+    if (!installDir.endsWith("/"))
+        installDir.append("/");
+
+    QString profileInfoFile = installDir + ".kdeprofile";
+    if (QFile::exists(profileInfoFile))
+    {
+        KConfig profileInfo(profileInfoFile, KConfig::SimpleConfig );
+        KConfigGroup profileInfoGroup = profileInfo.group("General");
+        description = profileInfoGroup.readEntry("Description");
+        installUser = profileInfoGroup.readEntry("InstallUser", "root");
+        return;
+    }
+
+    QString defaultDescription;
+    if (profile == "default")
+        defaultDescription = i18n("Default profile");
+
+    description = grp.readEntry("ProfileDescription", defaultDescription);
+    installUser = grp.readEntry("ProfileInstallUser", "root");
+}
+
+// strip illegal characters from names used in KAuth/its backends
+QString stripIllegal (const QString & input)
+{
+    // make action name lowercase
+    QString lowerAction = input.toLower();
+
+    // strip unsupported characters
+    QString stripped;
+    stripped.reserve(lowerAction.length());
+    for(int i = 0; i < lowerAction.length(); i++)
+    {
+        QChar c = lowerAction[i];
+        if((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9'))
+        {
+            stripped.append(c);
+        }
+    }
+    return stripped;
+}
+
+// delete all generated Kiosk PKLA settings
+void killAllPKLA()
+{
+    static QString path("/var/lib/polkit-1/localauthority/99-kiosk.d");
+    QDir dir(path);
+    if(dir.exists())
+    {
+        QDirIterator fileiter(path,QDir::Filters(QDir::Files));
+        while (fileiter.hasNext())
+        {
+            QFile::remove(fileiter.next());
+        }
+        dir.rmdir(path);
+    }
+}
+
+// Write contents to the PKLA hierarchy
+void writeToPKLA(const QString & contents, int index, const QString & name)
+{
+    static QString dirpath("/var/lib/polkit-1/localauthority/99-kiosk.d");
+    // create directory for Kiosk pkla files
+    {
+        QDir d(dirpath);
+        if(!d.exists())
+        {
+            d.mkpath(dirpath);
+            QFile setperm(dirpath);
+            QFile::Permissions ownage = QFile::ReadOwner | QFile::WriteOwner | QFile::ExeOwner;
+            setperm.setPermissions(ownage);
+        }
+    }
+    QFile::Permissions ownage = QFile::ReadOwner | QFile::WriteOwner;
+    QFile toWrite(QString("/var/lib/polkit-1/localauthority/99-kiosk.d/%1-%2.pkla").arg(index).arg(name));
+    toWrite.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text);
+    toWrite.write(contents.toUtf8());
+    toWrite.setPermissions(ownage);
+    toWrite.flush();
+    toWrite.close();
+}
+
+QString formatGroupPKLAEntry(const QString& unixgroup, const QString & action, bool value, int &index)
+{
+    QString retstring;
+    retstring.append(QString("[generated-%1]\n").arg(index));
+    retstring.append(QString("Identity=unix-group:%1\n").arg(unixgroup));
+    retstring.append(QString("Action=%1\n").arg(action));
+    if(value == true)
+    {
+        retstring.append(QString("ResultAny=yes\n"));
+        retstring.append(QString("ResultInactive=yes\n"));
+        retstring.append(QString("ResultActive=yes\n"));
+    }
+    else
+    {
+        retstring.append(QString("ResultAny=no\n"));
+        retstring.append(QString("ResultInactive=no\n"));
+        retstring.append(QString("ResultActive=no\n"));
+    }
+    return retstring;
+}
+
+// process a single KConfig group into entries for the group-assigned Kiosk profile
+QString unixgroupProcessEntryGroup(const QString & unixgroup,
+                                   const KConfigGroup & gr,
+                                   const QStringList & validEntries,
+                                   const QString & nspace,
+                                   int &index)
+{
+    QString aggregate;
+    // get map of entries
+    QStringList groupKeys = gr.keyList();
+    //qDebug() << unixgroup << nspace << " :: " << groupKeys.join(":");
+    // load all entries in order
+    foreach (QString str, groupKeys)
+    {
+        bool allowed = gr.readEntry<bool>(str,true);
+        //bool en_immutable = gr.isEntryImmutable(str);
+        QString strippedName = stripIllegal(str);
+        // create full action name
+        QString actionname = nspace + QChar('.');
+        actionname += strippedName;
+        //qDebug() << "Probing for action" << actionname;
+        // is it among known names?
+        if(validEntries.contains(actionname))
+        {
+            // yes? create a new entry;
+            aggregate += formatGroupPKLAEntry(unixgroup,actionname,allowed,index);
+            aggregate += '\n';
+            index++;
+        }
+        /*
+        else
+        {
+            qDebug() << "NOT FOUND";
+        }
+        */
+    }
+    qDebug() << aggregate;
+    return aggregate;
+}
+
+// creates a PKLA file for all groups
+QString createGroupFile (const QMap<QString, KConfig *> &AllProfiles,
+                         const QStringList &validActions,
+                         const QStringList &validResources,
+                         const ProfileMapping &groups,
+                         const QStringList &groupOrder)
+{
+    QString aggregate;
+    static QString actionNS("org.kde.kiosk.action");
+    static QString resourceNS("org.kde.kiosk.resource");
+    int index = 0;
+    // for each group in proper order
+    foreach(QString unixgroup, groupOrder)
+    {
+        // get Kiosk profiles
+        const QStringList & gProfiles = groups[unixgroup];
+        //qDebug() << "Group" << unixgroup << "profiles" << gProfiles.join(":");
+        
+        // for each profile, process KConfig objects
+        foreach(QString profile, gProfiles)
+        {
+            KConfig * conf = AllProfiles[profile];
+            // do all actions
+            KConfigGroup cfgGroupA = conf->group("KDE Action Restrictions");
+            if(cfgGroupA.exists())
+            {
+                aggregate += unixgroupProcessEntryGroup(unixgroup, cfgGroupA, validActions, actionNS, index);
+            }
+            /*
+            else
+                qDebug() << "No Action group in KConfig file";
+            */
+            // do all resources
+            KConfigGroup cfgGroupR = conf->group("KDE Resource Restrictions");
+            if(cfgGroupR.exists())
+            {
+                aggregate += unixgroupProcessEntryGroup(unixgroup, cfgGroupR, validResources, resourceNS, index);
+            }
+            /*
+            else
+                qDebug() << "No Resource group in KConfig file";
+            */
+        }
+    }
+    //qDebug() << aggregate;
+    return aggregate;
+}
+
+QString formatUserPKLAEntry(const QString& unixuser, const QString & action, bool value, int &index)
+{
+    QString retstring;
+    retstring.append(QString("[generated-%1]\n").arg(index));
+    retstring.append(QString("Identity=unix-user:%1\n").arg(unixuser));
+    retstring.append(QString("Action=%1\n").arg(action));
+    if(value == true)
+    {
+        retstring.append(QString("ResultAny=yes\nResultInactive=yes\nResultActive=yes\n"));
+    }
+    else
+    {
+        retstring.append(QString("ResultAny=no\nResultInactive=no\nResultActive=no\n"));
+    }
+    return retstring;
+}
+
+QString userProcessEntryGroup(const QString & unixuser,
+                              const KConfigGroup & gr,
+                              const QStringList & validEntries,
+                              const QString & nspace,
+                              int &index)
+{
+    QString aggregate;
+   
+    // first override all valid actions of our namespace
+    // with user profiles loade after group profiles,
+    // this means, that a user with a user profile won't have any group
+    // profiles applied to him. This mimics the way KConfig works to *some*
+    // extent
+    /*
+    foreach (QString entryname, validEntries)
+    {
+        aggregate += formatUserPKLAEntry(unixuser,entryname,true,index);
+        aggregate += '\n';
+        index++;
+    }
+    */
+    aggregate += formatUserPKLAEntry(unixuser,nspace + ".*",true,index);
+    
+    // get map of entries
+    QStringList groupKeys = gr.keyList();
+    
+    // load all entries in order
+    foreach (QString str, groupKeys)
+    {
+        bool allowed = gr.readEntry<bool>(str,true);
+        if(allowed) continue;
+        //bool en_immutable = gr.isEntryImmutable(str);
+        QString strippedName = stripIllegal(str);
+        // create full action name
+        QString actionname = nspace + QChar('.');
+        actionname += strippedName;
+        //qDebug() << "Probing for action" << actionname;
+        // is it among known names?
+        if(validEntries.contains(actionname))
+        {
+            // yes? create a new entry;
+            aggregate += formatUserPKLAEntry(unixuser,actionname,allowed,index);
+            aggregate += '\n';
+            index++;
+        }
+        /*
+        else
+        {
+            qDebug() << "NOT FOUND";
+        }
+        */
+    }
+    qDebug() << aggregate;
+    return aggregate;
+}
+
+
+QString createUserFile (const KConfig * config,
+                        const QStringList &validActions,
+                        const QStringList &validResources,
+                        const QString &userName)
+{
+    QString aggregate;
+    static QString actionNS("org.kde.kiosk.action");
+    static QString resourceNS("org.kde.kiosk.resource");
+    int index = 0;
+    // do all actions
+    KConfigGroup cfgGroupA = config->group("KDE Action Restrictions");
+    aggregate += userProcessEntryGroup(userName, cfgGroupA, validActions, actionNS, index);
+    
+    // do all resources
+    KConfigGroup cfgGroupR = config->group("KDE Resource Restrictions");
+    aggregate += userProcessEntryGroup(userName, cfgGroupR, validResources, resourceNS, index);
+    // return
+    return aggregate;
+}
+
+ActionReply KioskPKLAHelper::convertall(const QVariantMap &args)
+{
+    ActionReply reply;
+    
+    // create main component. yay for KConfig and friends
+    KComponentData data( "kioskpklahelper" );
+    // force things to init. possibly not needed
+    KStandardDirs * dirs = data.dirs();
+    KSharedConfigPtr conf = KGlobal::config();
+    
+    ProfileMapping groups, users;
+    QStringList groupOrder;
+    
+    getUserProfileMappings( groups, users, groupOrder);
+    
+    QString prefix = getProfilePrefix();
+    QStringList profilenames = getAllProfiles();
+    
+    // get all known polkit-1 actions
+    PolkitQt1::ActionDescription::List KnownPKActions =
+        PolkitQt1::Authority::instance()->enumerateActionsSync();
+    
+    // turn their IDs into a QStringList
+    QStringList allPolkitActions;
+    foreach(PolkitQt1::ActionDescription * adesc, KnownPKActions)
+    {
+        allPolkitActions += adesc->actionId();
+    }
+    
+    // get valid actions and resources from the PolicyKit1 Authority
+    QRegExp rgxpAction("^org\.kde\.kiosk\.action.*");
+    QRegExp rgxpResource("^org\.kde\.kiosk\.resource.*");
+    
+    QStringList validActions = allPolkitActions.filter(rgxpAction);
+    QStringList validResources = allPolkitActions.filter(rgxpResource);
+    /*
+    qDebug() << "Valid Actions!";
+    foreach(QString aaa, validActions)
+    {
+        qDebug() << aaa;
+    }
+    */
+    // load profiles into our little cache here
+    QMap<QString, KConfig *> AllProfiles;
+    foreach (QString profileName, profilenames)
+    {
+        QString description;
+        QString installDir;
+        QString installUser;
+        getProfileInfo(profileName, description,installDir,installUser);
+        //get a KConfig object from the kdeglobals file (if any)
+        KConfig * globals = new KConfig(installDir + QLatin1String("share/config/kdeglobals"), KConfig::SimpleConfig);
+        AllProfiles[profileName] = globals;
+    }
+    
+    // remove previously installed PKLA files
+    killAllPKLA();
+    
+    // make one file for all groups
+    QString groupFile = 
+        createGroupFile(AllProfiles,validActions,validResources,groups,groupOrder);
+    int index = 0;
+    writeToPKLA(groupFile,index,QString("kde.kiosk.groups"));
+    index ++;
+    
+    // make a file for each user
+    ProfileMapping::iterator i;
+    for (i = users.begin(); i != users.end(); ++i)
+    {
+        QString unixuser = i.key();
+        QString profile = i.value().first();
+        qDebug() << "User" << unixuser << "profile" << profile;
+        KConfig * globals = AllProfiles[profile];
+        QString userFile = 
+            createUserFile(globals,validActions, validResources, unixuser);
+        writeToPKLA(userFile,index,QString("kde.kiosk.user.%1").arg(unixuser));
+    }
+    
+    QVariantMap retdata;
+    retdata["contents"] = QString("This is the PKLA converter helper!");
+    reply.setData(retdata);
+    return reply;
+}
+
+KDE4_AUTH_HELPER_MAIN("org.kde.kiosk.pklahelper", KioskPKLAHelper)
Index: kdecore/auth/backends/mac/AuthServicesBackend.cpp
===================================================================
--- kdecore/auth/backends/mac/AuthServicesBackend.cpp	(revision 1125109)
+++ kdecore/auth/backends/mac/AuthServicesBackend.cpp	(working copy)
@@ -54,6 +54,11 @@
 
 Action::AuthStatus AuthServicesBackend::actionStatus(const QString &action)
 {
+    // check if the action exists first, return error if not
+    OSStatus exists = AuthorizationRightGet(action.toUtf8(), NULL);
+    if(exists != errAuthorizationSuccess)
+        return Action::Invalid;
+    
     AuthorizationItem item;
     item.name = action.toUtf8();
     item.valueLength = 0;
Index: kdecore/auth/backends/polkit-1/Polkit1Backend.cpp
===================================================================
--- kdecore/auth/backends/polkit-1/Polkit1Backend.cpp	(revision 1125767)
+++ kdecore/auth/backends/polkit-1/Polkit1Backend.cpp	(working copy)
@@ -22,6 +22,7 @@
 #include "Polkit1Backend.h"
 
 #include <QtCore/qplugin.h>
+#include <QtCore/QDebug>
 #include <syslog.h>
 #include <PolkitQt1/Authority>
 #include <PolkitQt1/Subject>
@@ -84,11 +85,27 @@
     PolkitQt1::UnixProcessSubject subject(QCoreApplication::applicationPid());
     PolkitQt1::Authority::Result r = PolkitQt1::Authority::instance()->checkAuthorizationSync(action, &subject,
                                                                                               PolkitQt1::Authority::None);
-    switch (r) {
+    
+    switch (r)
+    {
     case PolkitQt1::Authority::Yes:
         return Action::Authorized;
+    case PolkitQt1::Authority::Unknown:
+    {
+        PolkitQt1::Authority::ErrorCode error = PolkitQt1::Authority::instance()->lastError();
+        PolkitQt1::Authority::instance()->clearError();
+        // E_CheckFailed should indicate that an action doesn't exist in the database
+        if(error == PolkitQt1::Authority::E_CheckFailed)
+        {
+            return Action::Invalid;
+        }
+        else
+        {
+            // other errors. we treat them like before
+            return Action::Denied;
+        }
+    }
     case PolkitQt1::Authority::No:
-    case PolkitQt1::Authority::Unknown:
         return Action::Denied;
     default:
         return Action::AuthRequired;
Index: kdecore/auth/backends/fake/FakeBackend.cpp
===================================================================
--- kdecore/auth/backends/fake/FakeBackend.cpp	(revision 1125109)
+++ kdecore/auth/backends/fake/FakeBackend.cpp	(working copy)
@@ -30,7 +30,7 @@
 Action::AuthStatus FakeBackend::authorizeAction(const QString &action)
 {
     Q_UNUSED(action)
-    return Action::Denied;
+    return Action::Invalid;
 }
 
 void FakeBackend::setupAction(const QString &action)
@@ -41,7 +41,7 @@
 Action::AuthStatus FakeBackend::actionStatus(const QString &action)
 {
     Q_UNUSED(action)
-    return Action::Denied;
+    return Action::Invalid;
 }
 
 QByteArray FakeBackend::callerID() const
Index: kdecore/auth/backends/policykit/PolicyKitBackend.cpp
===================================================================
--- kdecore/auth/backends/policykit/PolicyKitBackend.cpp	(revision 1125109)
+++ kdecore/auth/backends/policykit/PolicyKitBackend.cpp	(working copy)
@@ -60,8 +60,9 @@
     switch (r) {
     case PolkitQt::Auth::Yes:
         return Action::Authorized;
+    case PolkitQt::Auth::Unknown:
+        return Action::Invalid;
     case PolkitQt::Auth::No:
-    case PolkitQt::Auth::Unknown:
         return Action::Denied;
     default:
         return Action::AuthRequired;
Index: kdecore/auth/kioskpklaconvert.cpp
===================================================================
--- kdecore/auth/kioskpklaconvert.cpp	(revision 0)
+++ kdecore/auth/kioskpklaconvert.cpp	(revision 0)
@@ -0,0 +1,76 @@
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <pwd.h>
+#include <grp.h>
+
+#include <QtCore/QCoreApplication>
+#include <QtCore/QFile>
+
+#include <kaboutdata.h>
+#include <kcmdlineargs.h>
+#include <kglobal.h>
+#include <klocale.h>
+#include <kcomponentdata.h>
+#include <kshell.h>
+#include <kstandarddirs.h>
+#include <kconfiggroup.h>
+#include <kauth.h>
+#include <kdebug.h>
+
+using namespace KAuth;
+
+int main(int argc, char **argv)
+{
+    QCoreApplication app(argc, argv);
+    KLocale::setMainCatalog("kioskpklaconvert");
+    KAboutData about("kioskpklaconvert",0, ki18n( "kioskpklaconvert" ), "1.0", ki18n("A tool to convert Kiosk profiles into PolicyKit1 Local Authority configuration."), KAboutData::License_GPL, ki18n( "(C) 2010 Petr Mrázek" ));
+    KCmdLineArgs::init( argc, argv, &about);
+    KComponentData mainComponent(about);
+    
+    
+    // get cmdline args here
+    
+    //KCmdLineOptions options;
+    //options.add("check", ki18n("Output currently active prefixes"));
+    //KCmdLineArgs::addCmdLineOptions(options);
+    KCmdLineArgs *args = KCmdLineArgs::parsedArgs();
+    
+    
+    
+    QVariantMap helperargs;
+    
+    // fill in helper args here
+    
+    Action action("org.kde.kiosk.pklahelper.convertall");
+    action.setHelperID("org.kde.kiosk.pklahelper");
+    action.setArguments(helperargs);
+
+    ActionReply reply = action.execute();
+
+    if (reply.failed())
+    {
+        if (reply.type() == ActionReply::KAuthError)
+        {
+            // There has been an internal KAuth error
+            kError() << "Unable to authenticate/execute the action:" << reply.errorCode() << " " << reply.errorDescription();
+        }
+        else
+        {
+            // There has been an internal KAuth error
+            kError() << "Reply:" << reply.errorCode() << " " << reply.errorDescription();
+        }
+    }
+    else
+    {
+        QVariantMap retdata = reply.data();
+        if(retdata.isEmpty())
+        {
+            kError() << "Reply is empty, helper didn't work :(";
+            kError() << "Reply:" << reply.type() << " " << reply.errorCode() << " " << reply.errorDescription();
+        }
+    }
+    return 0;
+}
+
+
Index: kdecore/auth/kioskpklahelper.h
===================================================================
--- kdecore/auth/kioskpklahelper.h	(revision 0)
+++ kdecore/auth/kioskpklahelper.h	(revision 0)
@@ -0,0 +1,36 @@
+/*
+ *  kioskpklahelper.h
+ *
+ *  Copyright (C) 2010 Petr Mrázek <xmraze03@stud.fit.vutbr.cz>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ */
+#ifndef KIOSK_PKLA_HELPER_H
+#define KIOSK_PKLA_HELPER_H
+
+#include <kauth.h>
+
+using namespace KAuth;
+
+class KioskPKLAHelper : public QObject
+{
+    Q_OBJECT
+
+    public slots:
+        ActionReply convertall(const QVariantMap &map);
+};
+
+#endif // KIOSK_PKLA_HELPER_H
Index: kdecore/CMakeLists.txt
===================================================================
--- kdecore/CMakeLists.txt	(revision 1125109)
+++ kdecore/CMakeLists.txt	(working copy)
@@ -398,6 +398,42 @@
 
 ########### next target ###############
 
+# Kiosk settings for KAuth, only with polkit1
+IF(KAUTH_BACKEND STREQUAL "POLKITQT-1")
+    kde4_install_auth_actions(org.kde.kiosk.action auth/org.kde.kiosk.action.actions)
+    kde4_install_auth_actions(org.kde.kiosk.resource auth/org.kde.kiosk.resource.actions)
+
+    kde4_add_executable(kioskpklahelper auth/kioskpklahelper.cpp ${helper_mocs})
+    # ugly, ugly - link the helper with polkit-qt-1
+    target_link_libraries(kioskpklahelper ${KDE4_KDECORE_LIBS} ${KAUTH_BACKEND_LIBS})
+    install(TARGETS kioskpklahelper DESTINATION ${LIBEXEC_INSTALL_DIR})
+
+    set ( kioskpklaconvert_SRCS
+    auth/kioskpklaconvert.cpp
+    )
+       
+    kde4_add_executable(kioskpklaconvert NOGUI ${kioskpklaconvert_SRCS})
+    target_link_libraries(kioskpklaconvert ${KDE4_KDECORE_LIBS})
+    install(TARGETS kioskpklaconvert ${INSTALL_TARGETS_DEFAULT_ARGS})
+           
+    kde4_install_auth_helper_files(kioskpklahelper org.kde.kiosk.pklahelper root)
+
+    kde4_install_auth_actions(org.kde.kiosk.pklahelper auth/pklahelper_actions.actions)
+ENDIF(KAUTH_BACKEND STREQUAL "POLKITQT-1")
+
+########### next target ###############
+
+# KAuth Action synchronous DoS test
+set ( kauthDoS_SRCS
+auth/kauthDoS.cpp
+)
+   
+kde4_add_executable(kauthDoS NOGUI ${kauthDoS_SRCS})
+target_link_libraries(kauthDoS ${KDE4_KDECORE_LIBS})
+install(TARGETS kauthDoS ${INSTALL_TARGETS_DEFAULT_ARGS})
+
+########### next target ###############
+
 configure_file(all_languages.desktop ${CMAKE_CURRENT_BINARY_DIR}/all_languages @ONLY)
 
 kde4_add_executable(kde4-config NOGUI kde-config.cpp )
